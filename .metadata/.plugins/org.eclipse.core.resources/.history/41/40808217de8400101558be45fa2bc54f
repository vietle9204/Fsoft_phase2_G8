/* ###################################################################
**     Filename    : main.c
**     Processor   : S32K1xx
**     Abstract    :
**         Main module.
**         This module contains user's application code.
**     Settings    :
**     Contents    :
**         No public methods
**
** ###################################################################*/
/*!
** @file main.c
** @version 01.00
** @brief
**         Main module.
**         This module contains user's application code.
*/         
/*!
**  @addtogroup main_module main module documentation
**  @{
*/         
/* MODULE main */


/* Including necessary module. Cpu.h contains other modules needed for compiling.*/
#include "Cpu.h"
#include "math.h"

  volatile int exit_code = 0;

  /* User includes (#include below this line is not maintained by Processor Expert) */

  /* Variables used to store PWM duty cycle */
  ftm_state_t ftmStateStruct;

#define Left_motor 1
#define Right_motor 2

#define Left_motor_forward_GPIO_port PTA
#define Left_motor_forward_GPIO_PIN 0U
#define Left_motor_reverse_GPIO_port PTA
#define Left_motor_reverse_GPIO_PIN 1U

#define Right_motor_forward_GPIO_port PTA
#define Right_motor_forward_GPIO_PIN 2U
#define Right_motor_reverse_GPIO_port PTA
#define Right_motor_reverse_GPIO_PIN 3U

#define direction_foward 1
#define direction_reverse -1

#define motor_number 2



  typedef enum {
	AC_on,
	AC_off,
	AC_error

  } air_conditioning_state;

	typedef enum {
		W_on,
		W_off,
		W_error

	} wiper_state;

	typedef enum {
		HL_on,
		HL_off,
		HL_error
	} headlight_state;

	typedef enum {
		Brake,                    //send to KIT3
		Get_left_motor_speed,     //send to KIT3
		Get_right_motor_speed,     //send to KIT3
		control_left_motor,       //  send to KIT2
		control_right_motor		  //  send to KIT2

	} Can_Request;

void delayCycles(volatile uint32_t cycles) {
	while (cycles--) {
	}
}

typedef struct {
	int motor_id;

	uint32_t PWM_instance;
	uint8_t PWM_channel;

	GPIO_Type *forward_GPIO_port;
	pins_channel_type_t forward_GPIO_PIN;

	GPIO_Type *reverse_GPIO_port;
	pins_channel_type_t reverse_GPIO_PIN;

	float current_speed;
	float target_speed;
	int direction;
// 	PID_Controller *pid;
} Motor_st;


Motor_st motor[2] = { { .motor_id = Left_motor,
// 				.pid = &(pid[0]),

		}, { .motor_id = Right_motor,
//  				.pid = &(pid[1]),
		} };

Motor_st* find_motor_by_id(int motor_id) {
	for (int i = 0; i < motor_number; i++) {
		if (motor_id == motor[i].motor_id)
			return &motor[i];
	}
	return NULL;
}

void MotorControl_Init(int motor_id, uint32_t PWM_instance, uint8_t PWM_channel,
		GPIO_Type *forward_GPIO_port, pins_channel_type_t forward_GPIO_PIN,
		GPIO_Type *reverse_GPIO_port, pins_channel_type_t reverse_GPIO_PIN) {
	Motor_st *motor = find_motor_by_id(motor_id);
	if (motor != NULL) {
		motor->PWM_instance = PWM_instance;
		motor->PWM_channel = PWM_channel;
		motor->forward_GPIO_port = forward_GPIO_port;
		motor->forward_GPIO_PIN = forward_GPIO_PIN;
		motor->reverse_GPIO_port = reverse_GPIO_port;
		motor->reverse_GPIO_PIN = reverse_GPIO_PIN;
	}

}

void set_speed_motor(int motor_id, float target_speed) {
	Motor_st *motor = find_motor_by_id(motor_id);

	if (motor != NULL) {

		if (target_speed > 100.0f)
			target_speed = 100.0f;
		else if (target_speed < -100.0f)
			target_speed = -100.0f;

		motor->target_speed = fabsf(target_speed);

		if (target_speed * motor->direction <= 0.0f) {

			if (target_speed >= 0) {
				motor->direction = direction_foward;
				PINS_DRV_ClearPins(motor->reverse_GPIO_port,
						1 << motor->reverse_GPIO_PIN);
				PINS_DRV_SetPins(motor->forward_GPIO_port,
						1 << motor->forward_GPIO_PIN);

			} else {
				motor->direction = direction_reverse;
				PINS_DRV_ClearPins(motor->forward_GPIO_port,
						1 << motor->forward_GPIO_PIN);
				PINS_DRV_SetPins(motor->reverse_GPIO_port,
						1 << motor->reverse_GPIO_PIN);
			}
		}

	}
}

void Motor_Stop(int motor_id) {
	Motor_st *motor = find_motor_by_id(motor_id);

	if (motor != NULL) {
		int duty = (uint32_t) (motor->target_speed) * 0x7000U / 100;
		while (duty > 0) {

			duty -= 0x500U;
			if (duty < 0)
				duty = 0;

			FTM_DRV_UpdatePwmChannel(motor->PWM_instance, motor->PWM_channel,
					FTM_PWM_UPDATE_IN_DUTY_CYCLE, duty, 0U, true);

			delayCycles(48000);
		}
		set_speed_motor(motor_id, 0);
	}

}

void Motor_Start(int motor_id) {
	Motor_st *motor = find_motor_by_id(motor_id);
	uint32_t duty = (uint32_t) (motor->target_speed) * 0x7000U / 100;
	if (motor != NULL) {
		FTM_DRV_UpdatePwmChannel(motor->PWM_instance, motor->PWM_channel,
				FTM_PWM_UPDATE_IN_DUTY_CYCLE, duty, 0U, true);
	}
}

void stop() {
	int duty0 = (uint32_t) (motor[0].target_speed) * 0x7000U / 100;
	int duty1 = (uint32_t) (motor[1].target_speed) * 0x7000U / 100;

	while (duty0 > 0 || duty1 > 0) {
		if (duty0 > 0) {
			duty0 -= 0x500;
			if (duty0 < 0)
				duty0 = 0;

			FTM_DRV_UpdatePwmChannel(motor[0].PWM_instance,
					motor[0].PWM_channel, FTM_PWM_UPDATE_IN_DUTY_CYCLE,
					(uint32_t) duty0, 0U, true);

		}

		if (duty1 > 0) {
			duty1 -= 0x500;
			if (duty1 < 0)
				duty1 = 0;

			FTM_DRV_UpdatePwmChannel(motor[1].PWM_instance,
					motor[1].PWM_channel, FTM_PWM_UPDATE_IN_DUTY_CYCLE,
					(uint32_t) duty1, 0U, true);
		}

		delayCycles(48000);
	}

	set_speed_motor(Left_motor, 0);
	set_speed_motor(Right_motor, 0);
}









/*
 * @brief : Initialize clocks, pins and power modes
 */
void BoardInit(void) {

	/* Initialize and configure clocks
	 *  -   Setup system clocks, dividers
	 *  -   Configure FlexCAN clock, GPIO
	 *  -   see clock manager component for more details
	 */
	CLOCK_SYS_Init(g_clockManConfigsArr, CLOCK_MANAGER_CONFIG_CNT,
			g_clockManCallbacksArr, CLOCK_MANAGER_CALLBACK_CNT);
	CLOCK_SYS_UpdateConfiguration(0U, CLOCK_MANAGER_POLICY_FORCIBLE);

	/* Initialize pins
	 *  -   Init FlexCAN and GPIO pins
	 *  -   See PinSettings component for more info
	 */
	PINS_DRV_Init(NUM_OF_CONFIGURED_PINS, g_pin_mux_InitConfigArr);
}

void PwmInit(void){
	/* Init  pin pwm channel 0 PB12, channel 1 PB13) */
	FTM_DRV_Init(INST_FLEXTIMER_PWM1, &flexTimer_pwm1_InitConfig,
			&ftmStateStruct);
	/* Initialize FTM PWM channel */
	FTM_DRV_InitPwm(INST_FLEXTIMER_PWM1, &flexTimer_pwm1_PwmConfig);
}


void PORTA_IRQHandler(void)
{
    uint32_t flags = PINS_DRV_GetPortIntFlag(PORTA);

    // PA14
    if (flags & (1 << 14)) {
        // Xử lý ngắt từ PA14
    	PINS_DRV_SetPins(PTA, 1 << 15U);


    	delayCycles(480000);
    	PINS_DRV_ClearPins(PTA, 1 << 15U);


    	Motor_Stop(Left_motor);
        // clear interrupt flag
        PINS_DRV_ClearPinIntFlagCmd(PORTA,14);
    }



    // PA16
    if (flags & (1 << 16)) {
        // Xử lý ngắt từ PA16
    	PINS_DRV_SetPins(PTA, 1 << 17U);



    	delayCycles(480000);
    	PINS_DRV_ClearPins(PTA, 1 << 17U);


    	Motor_Stop(Right_motor);

    	// clear interrupt flag
        PINS_DRV_ClearPinIntFlagCmd(PORTA, 16);
    }


}


//void PORTC_IRQHandler(void) {
//	uint32_t flags = PINS_DRV_GetPortIntFlag(PORTC) & (0xFU << 14);
//
//	// PC14
//	if (flags & (1 << 14)) {
//		// Xử lý ngắt từ PC14
//
//
//
//		PINS_DRV_ClearPinIntFlagCmd(PORTC, 14);
//	}
//
//	// PC15
//	if (flags & (1 << 15)) {
//		// Xử lý ngắt từ PC15
//
//
//
//		PINS_DRV_ClearPinIntFlagCmd(PORTC, 15);
//	}
//
//	// PC16
//	if (flags & (1 << 16)) {
//		// Xử lý ngắt từ PC16
//
//
//
//		PINS_DRV_ClearPinIntFlagCmd(PORTC, 16);
//	}
//
//	// PC17
//	if (flags & (1 << 17)) {
//		// Xử lý ngắt từ PC17
//
//
//
//		PINS_DRV_ClearPinIntFlagCmd(PORTC, 17);
//	}
//
//}




/*
 * Initialize interrupt
 * install interrupt handler
 * manager priority
 */
void InterruptInit(void)
{
//		/*Can    */
//		INT_SYS_SetPriority(CAN0_ORed_IRQn, 0);
//		INT_SYS_EnableIRQ(CAN0_ORed_IRQn);
//
//		/*Lin	   */
//		INT_SYS_SetPriority(LPUART2_RxTx_IRQn, 1);
//		INT_SYS_EnableIRQ(LPUART2_RxTx_IRQn);


	  /* enable interrupt port A and init handler */
		INT_SYS_InstallHandler(PORTA_IRQn, &PORTA_IRQHandler, NULL);
		INT_SYS_SetPriority(PORTA_IRQn, 2);
		INT_SYS_EnableIRQ(PORTA_IRQn);

//	  /* enable interrupt port C and init handler */
//		INT_SYS_InstallHandler(PORTC_IRQn, &PORTC_IRQHandler, NULL);
//		INT_SYS_SetPriority(PORTC_IRQn, 3);
//		INT_SYS_EnableIRQ(PORTC_IRQn);
}


void Can_RequestHandler(uint8_t request, uint16_t data) {
	switch (request) {

	case control_left_motor:

		set_speed_motor(Left_motor, data);      // data: speed [-100 : 100]
		Motor_Start(Left_motor);

		break;
	case control_right_motor:

		set_speed_motor(Right_motor, data);
		Motor_Start(Right_motor);

		break;


	default:
		break;
	}
}


//	void Lin_RequestHandler(uint8_t request, uint16_t data)
//	{
//
//	}

/*
 *
 *
 *
 *
 *
 * CAN
 *
 *
 *
 *
 */

#define CAN_SLAVE

	/* CAN ID và Mailbox */
	#if defined(CAN_MASTER)
	#define TX_MAILBOX_REQ    (0UL)
	#define TX_MSG_ID_REQ     (0x4UL)   // Gửi yêu cầu phanh

	#define RX_MAILBOX_RESP   (1UL)
	#define RX_MSG_ID_RESP    (0x6UL)   // Nhận phản hồi trạng thái phanh

	#define RX_MAILBOX_SPEED   (2UL)
	#define RX_MSG_ID_SPEED    (0x5UL)   // Nhận tốc độ từ Slave

	#define TX_MAILBOX  (3UL)
	#define TX_MSG_ID   (7UL)
//	#define RX_MAILBOX  (8UL)
//	#define RX_MSG_ID   (9UL)
	#endif

	#if defined(CAN_SLAVE)
	#define RX_MAILBOX_REQ    (0UL)
	#define RX_MSG_ID_REQ     (0x4UL)   // Nhận yêu cầu phanh

	#define TX_MAILBOX_SPEED  (1UL)
	#define TX_MSG_ID_SPEED   (0x5UL)   // Gửi tốc độ 2 bánh

	#define TX_MAILBOX_BRAKE  (2UL)
	#define TX_MSG_ID_BRAKE   (0x6UL)   // Phản hồi trạng thái phanh

//	#define TX_MAILBOX  (8UL)
//	#define TX_MSG_ID   (9UL)
	#define RX_MAILBOX  (3UL)
	#define RX_MSG_ID   (7UL)
	#endif

//	/* Definition of the TX and RX message buffers depending on the bus role */
//	#if defined(MASTER)
//	#define TX_MAILBOX  (1UL)
//	#define TX_MSG_ID   (1UL)
//	#define RX_MAILBOX  (0UL)
//	#define RX_MSG_ID   (2UL)
//
//	#elif defined(SLAVE)
//	#define TX_MAILBOX  (0UL)
//	#define TX_MSG_ID   (2UL)
//	#define RX_MAILBOX  (1UL)
//	#define RX_MSG_ID   (1UL)
//	#endif




	/* Hàm gửi dữ liệu CAN */
	void SendCANData(uint32_t mailbox, uint32_t messageId, uint8_t * data, uint32_t len)
	{
	    flexcan_data_info_t dataInfo =
	    {
	        .data_length = len,
	        .msg_id_type = FLEXCAN_MSG_ID_STD,
	        .enable_brs  = false,
	        .fd_enable   = false,
	        .fd_padding  = 0U
	    };

	    FLEXCAN_DRV_ConfigTxMb(INST_CANCOM1, mailbox, &dataInfo, messageId);
	    FLEXCAN_DRV_Send(INST_CANCOM1, mailbox, &dataInfo, messageId, data);
	}



	/*
		 *
		 *  Callback CAN RX
		 */
	int l_speed;
	int r_speed;
	int set_speed_flag = 0;
	void CAN_RxCallback(uint8_t instance,
	                    flexcan_event_type_t eventType,
	                    uint32_t mbIdx,
	                    void *userData)
	{
	    (void) instance;

	    if (eventType == FLEXCAN_EVENT_RX_COMPLETE)
	    {
	        flexcan_msgbuff_t *rxBuff = (flexcan_msgbuff_t *)userData;

		#if defined(CAN_SLAVE)
			if (rxBuff->msgId == RX_MSG_ID && rxBuff->dataLen >= 2) {

				if(rxBuff->data[0] == 0)
					l_speed =(int) (rxBuff->data[1]) - 128;
				else
					r_speed =(int) (rxBuff->data[1]) -128;

				set_speed_flag = 1;
			}
		#endif
	        /* Re-arm only the mailbox that triggered */
	        FLEXCAN_DRV_Receive(INST_CANCOM1, mbIdx, rxBuff);
	    }
	}




	/*
	 *  Init CAN
	 *
	 */
		void FlexCANInit(void)
		{
		    FLEXCAN_DRV_Init(INST_CANCOM1, &canCom1_State, &canCom1_InitConfig0);

		    /* Cấu hình thông tin nhận */
		    flexcan_data_info_t dataInfo = {
		        .data_length = 2U,
		        .msg_id_type = FLEXCAN_MSG_ID_STD,
		        .enable_brs = false,
		        .fd_enable = false,
		        .fd_padding = 0U
		    };

		    static flexcan_msgbuff_t rxBuff;
		       /* Configure RX message buffer with index RX_MSG_ID and RX_MAILBOX */
		       FLEXCAN_DRV_ConfigRxMb(INST_CANCOM1, RX_MAILBOX, &dataInfo, RX_MSG_ID);
		       FLEXCAN_DRV_Receive(INST_CANCOM1, RX_MAILBOX, &rxBuff);
		    /* Install callback and pass pointer to rxBuff */
		    FLEXCAN_DRV_InstallEventCallback(INST_CANCOM1, CAN_RxCallback, &rxBuff);
		}











/*! 
  \brief The main function for the project.
  \details The startup initialization sequence is the following:
 * - startup asm routine
 * - main()
*/
int main(void)
{
  /* Write your local variable definition here */

  /*** Processor Expert internal initialization. DON'T REMOVE THIS CODE!!! ***/
  #ifdef PEX_RTOS_INIT
    PEX_RTOS_INIT();                   /* Initialization of the selected RTOS. Macro is defined by the RTOS component. */
  #endif
  /*** End of Processor Expert internal initialization.                    ***/

  /* Write your code here */

    BoardInit();

    PwmInit();

	InterruptInit();

    MotorControl_Init(Left_motor, INST_FLEXTIMER_PWM1, 0U,
						Left_motor_forward_GPIO_port, Left_motor_forward_GPIO_PIN,
						Left_motor_reverse_GPIO_port, Left_motor_reverse_GPIO_PIN);
	MotorControl_Init(Right_motor, INST_FLEXTIMER_PWM1, 1U,
						Right_motor_forward_GPIO_port, Right_motor_forward_GPIO_PIN,
						Right_motor_reverse_GPIO_port, Right_motor_reverse_GPIO_PIN);

	FlexCANInit();

  /* For example: for(;;) { } */

	while (1) {

		if(set_speed_flag)
		{
			PINS_DRV_TogglePins(PTD, 1 << 15 | 1 << 16 | 1 << 0);
			set_speed_motor(Left_motor,(float) l_speed);
			set_speed_motor(Right_motor,(float) r_speed);
			Motor_Start(Left_motor);
			Motor_Start(Right_motor);
			set_speed_flag = 0;
		}


//	        // Tăng tốc tới 50%
//	        set_speed_motor(Left_motor, 50.0f);
//	        set_speed_motor(Right_motor, 50.0f);
//	        Motor_Start(Left_motor);
//	        Motor_Start(Right_motor);
//	        delayCycles(48000000);  // delay 1 giây (tùy xung nhịp CPU)
//
//	        // Dừng động cơ từ từ
//	        stop();
//	        delayCycles(48000000);
//
//	        // Quay ngược 30%
//	        set_speed_motor(Left_motor, -30.0f);
//	        set_speed_motor(Right_motor, -30.0f);
//	        Motor_Start(Left_motor);
//	        Motor_Start(Right_motor);
//	        delayCycles(48000000);
//
//		// Tăng tốc tới 50%
//		set_speed_motor(Left_motor, -50.0f);
//		set_speed_motor(Right_motor, 50.0f);
//		Motor_Start(Left_motor);
//		Motor_Start(Right_motor);
//		delayCycles(48000000);  // delay 1 giây (tùy xung nhịp CPU)
//
//		// Dừng động cơ từ từ
//		stop();
//		delayCycles(48000000);
//
//	        // Dừng động cơ
//	        stop();
//	        delayCycles(48000000);
	    }

  /*** Don't write any code pass this line, or it will be deleted during code generation. ***/
  /*** RTOS startup code. Macro PEX_RTOS_START is defined by the RTOS component. DON'T MODIFY THIS CODE!!! ***/
  #ifdef PEX_RTOS_START
    PEX_RTOS_START();                  /* Startup of the selected RTOS. Macro is defined by the RTOS component. */
  #endif
  /*** End of RTOS startup code.  ***/
  /*** Processor Expert end of main routine. DON'T MODIFY THIS CODE!!! ***/
  for(;;) {
    if(exit_code != 0) {
      break;
    }
  }
  return exit_code;
  /*** Processor Expert end of main routine. DON'T WRITE CODE BELOW!!! ***/
} /*** End of main routine. DO NOT MODIFY THIS TEXT!!! ***/

/* END main */
/*!
** @}
*/
/*
** ###################################################################
**
**     This file was created by Processor Expert 10.1 [05.21]
**     for the NXP S32K series of microcontrollers.
**
** ###################################################################
*/
